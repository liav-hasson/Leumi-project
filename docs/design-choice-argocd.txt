* draft document

about argo design choices i made

Why App-of-Apps? 
    I wanted to seperate all configurations from terraform and use Git as a source of truth.
    That way, i can dynamically configure environments and modify them easily using helm charts.
    Using app-of-apps, i can deploy a single resource to the cluster - the root application.

    The root application centralizes the bootstrap process: ArgoCD syncs the root app once, which then installs foundational components (ALB controller, External Secrets, Jenkins platform, quiz app) with ordered sync waves to avoid conflicts. 

Why not individual Applications or an ApplicationSet? 
    Managing each application separately is a valid strategy as long as the scale is low.
    When the application amout grows, using apps-of-apps is important to avoid manual creation/synchronization and dependency ordering issues. 
    ApplicationSets shine when you need many similar apps (clusters, tenants) generated from templates, which isn’t the case here. The footprint is a small, fixed collection of components, so a static apps-of-apps is simpler and more deterministic.


What type of secret resources do i use in argocd? for what and why?

## Secret Management Architecture

The platform uses three types of secret resources, each serving different purposes:

### 1. ClusterSecretStore (External Secrets Operator CRD)
**Resource Type:** Cluster-scoped configuration
**Location:** `gitops/quiz-app/templates/external-secrets.yaml`
**Purpose:** Defines HOW to access AWS SSM Parameter Store

**What it holds:**
- AWS region: eu-north-1
- Authentication method: IRSA (IAM Roles for Service Accounts)
- Service account reference: external-secrets/external-secrets-system

**Use Case:**
- Single, centralized configuration for all ExternalSecrets in the cluster
- No secrets stored directly - just the access pattern
- Uses IRSA pod identity (no AWS keys needed)
- Shared across all namespaces (quiz-app, jenkins)

**Why this design:**
- Eliminates duplicate configuration across namespaces
- Security: Uses IAM roles instead of static credentials
- ArgoCD can track it like any other K8s resource

---

### 2. ExternalSecret (External Secrets Operator CRD)
**Resource Type:** Namespaced custom resource
**Purpose:** Syncs specific secrets from AWS SSM → Kubernetes Secrets

#### A. Quiz App - OpenAI API Key
**Location:** `gitops/quiz-app/templates/external-secrets.yaml`
**Source:** AWS SSM Parameter `/devops-quiz/openai-api-key`
**Target:** K8s Secret `quiz-app-secrets` in `quiz-app` namespace
**Refresh:** Every 1 hour

**What it holds:**
- SSM parameter path: `/devops-quiz/openai-api-key`
- Target secret name: `quiz-app-secrets`
- Secret key: `OPENAI_API_KEY`

**Used by:** 
- Quiz app deployment reads secret as environment variable
- Injected into pods at: `gitops/quiz-app/templates/deployment.yaml` (lines 33-38)

**Why:**
- OpenAI API key never stored in Git
- Automatic rotation (ESO syncs every hour)
- ArgoCD can reconcile the ExternalSecret manifest (not the actual secret value)

#### B. Jenkins Platform - Docker Hub Credentials
**Location:** `gitops/jenkins-platform/templates/docker-credentials-externalsecret.yaml`
**Source:** AWS SSM Parameter `/weatherlabs/app/docker-registry-config`
**Target:** K8s Secret `docker-config` in `jenkins` namespace
**Format:** Docker config.json format

**What it holds:**
- Docker Hub username: liavvv
- Docker Hub access token: dckr_pat_...
- Registry URL: https://index.docker.io/v1/

**Used by:**
- BuildKit DaemonSet for pushing built images to Docker Hub
- Jenkins agents for pulling private images (liavvv/jenkins-agent, liavvv/quiz-app)

**Why:**
- Docker credentials never in Git
- BuildKit can authenticate to private registries
- Same credentials used across all build pods

---

### 3. Native Kubernetes Secret (kubernetes.io/service-account-token)
**Resource Type:** Standard K8s Secret
**Location:** `gitops/jenkins-platform/templates/sa-token-secret.yaml`
**Purpose:** Static token for Jenkins controller (EC2) → EKS API authentication

**What it holds:**
- ServiceAccount token (auto-generated by Kubernetes)
- CA certificate for EKS cluster
- Namespace: jenkins

**Used by:**
- Jenkins controller running on EC2 (outside the cluster)
- Jenkins Kubernetes Cloud plugin authenticates with this token
- Allows Jenkins to create pods for build jobs

**Why native K8s Secret (not ExternalSecret):**
- ServiceAccount tokens are Kubernetes-native constructs
- Token is auto-generated by K8s when Secret is created
- No external source to sync from (it's a K8s-internal credential)
- Must use type `kubernetes.io/service-account-token` for auto-population

**Special ArgoCD handling:**
- `ignoreDifferences` configured in `gitops/applications/jenkins-platform.yaml`
- ArgoCD ignores drift in `token` and `ca.crt` fields
- These fields are auto-generated by K8s, not from Git

---

## Summary Table

| Secret Type | Secret Name | Namespace | Source | Contains | Consumer | Managed By |
|-------------|-------------|-----------|--------|----------|----------|------------|
| **ClusterSecretStore** | aws-parameter-store | cluster-wide | N/A (config only) | AWS region, IRSA config | ExternalSecrets | External Secrets Operator |
| **ExternalSecret** | openai-api-key | quiz-app | SSM: /devops-quiz/openai-api-key | OPENAI_API_KEY | Quiz app pods | External Secrets Operator |
| **ExternalSecret** | docker-registry-credentials | jenkins | SSM: /weatherlabs/app/docker-registry-config | Docker Hub auth | BuildKit, Jenkins agents | External Secrets Operator |
| **Native Secret** | jenkins-token | jenkins | ServiceAccount: jenkins | K8s API token, CA cert | Jenkins controller (EC2) | Kubernetes API |

---

## Secret Flow Diagram

```
AWS SSM Parameter Store                     Kubernetes Cluster
┌─────────────────────────┐                ┌─────────────────────────────┐
│                         │                │                             │
│ /devops-quiz/           │                │  ClusterSecretStore         │
│   openai-api-key        │◄───IRSA────────│  (aws-parameter-store)      │
│                         │                │  ↓                          │
│ /weatherlabs/app/       │                │  ExternalSecret             │
│   docker-registry-config│                │  ↓                          │
│                         │                │  K8s Secret (auto-created)  │
└─────────────────────────┘                │  ↓                          │
                                           │  Pod (env var injection)    │
                                           └─────────────────────────────┘

Kubernetes API (ServiceAccount)            Jenkins Controller (EC2)
┌─────────────────────────┐                ┌─────────────────────────────┐
│ ServiceAccount: jenkins │                │                             │
│ ↓                       │                │  Reads token from Secret    │
│ Secret: jenkins-token   │◄───kubectl─────│  jenkins-token              │
│   token: eyJhbGc...     │                │  ↓                          │
│   ca.crt: LS0tLS...     │                │  Authenticates to K8s API   │
└─────────────────────────┘                │  ↓                          │
                                           │  Creates build pods         │
                                           └─────────────────────────────┘
```

---

## Use Case Comparison

**When to use ExternalSecret:**
- Credentials stored in external vault (AWS SSM, Secrets Manager, Vault, etc.)
- Need automatic rotation/refresh
- Want GitOps for secret definitions (not values)
- Application secrets (API keys, database passwords, etc.)

**When to use Native K8s Secret:**
- Kubernetes-internal credentials (ServiceAccount tokens, TLS certs from cert-manager)
- Auto-generated values by K8s controllers
- No external source to sync from
- Need specific K8s Secret types (service-account-token, tls, docker-registry)

**Why NOT store secrets directly in Git:**
- Security risk: credentials exposed in version control
- Rotation nightmare: must update Git and redeploy
- Audit trail: can't track who accessed secrets in Git history
- Compliance: violates security best practices